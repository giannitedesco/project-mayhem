#!/usr/bin/python

import pymayhem
import mayhem
from urlparse import urlparse
import httplib
import threading
import gobject, glib, gtk, pango
import pygst
#pygst.require('0.10')
import gst
from collections import deque

class VidSource:
	def read(self, sz = 4096):
		raise Exception
	def ready(self):
		return True
	def __init__(self):
		pass

class VidStream(VidSource):
	def read(self, sz = 0):
		buf = self.bufs.popleft()
		self.cur_sz -= len(buf)
		return buf
	def ready(self):
		if not self.cur_sz or self.prebuffer:
			return False
		return self.cur_sz > 0
	def push(self, buf):
		self.bufs.append(buf)
		self.cur_sz += len(buf)
		if len(buf) >= self.prebuffer:
			if self.prebuffer:
				print 'buffered'
			self.prebuffer = 0
		else:
			self.prebuffer -= len(buf)
#			print '%d Kbytes to fill'%(self.prebuffer >> 10)
		self.out.write(buf)

	def __init__(self, prebuffer = (1 << 19)):
		self.bufs = deque()
		self.prebuffer = prebuffer
		self.cur_sz = 0
		self.out = file('out.flv', 'w')

class VidFile(VidSource):
	def read(self, sz = 4096):
		return self.f.read(sz)
	def __init__(self, fn):
		self.f = open(fn)

class VidPipeline(gst.Pipeline):
	def codec_by_name(self, codec):
		if codec == 'video/x-vp6-flash':
			self.vdec = gst.element_factory_make('ffdec_vp6f',
								'vdec')
		else:
			self.vdec = gst.element_factory_make('ffdec_h264',
								'vdec')
		self.add(self.vdec)
		self.vdec.sync_state_with_parent()

	def demux_pad(self, demux, pad):
		n = pad.get_property('template').name_template
		if n == 'video':
			codec = pad.get_caps().get_structure(0).get_name()
			self.codec_by_name(codec)
			qv_pad = self.qv.get_pad('sink')
			pad.link(qv_pad)
			gst.element_link_many(self.qv, self.vdec, self.cspace)
		elif n == 'audio':
			qa_pad = self.qa.get_pad('sink')
			pad.link(qa_pad)

	def need_data(self, src, size):
#		print 'need-data', size
		self.needy = True
		while self.vid.ready():
			buf = self.vid.read()
			self.appsrc.emit('push-buffer', gst.Buffer(buf))
	def enough_data(self, src):
#		print 'enough-data'
		self.needy = False

	def push_data(self, buf):
#		print 'push-data'
		self.vid.push(buf)
		while self.needy and self.vid.ready():
			buf = self.vid.read()
			self.appsrc.emit('push-buffer', gst.Buffer(buf))

	def set_xwindow_id(self, xid):
		self.vsink.set_xwindow_id(xid)

	def __init__(self, vid, name = 'VidPipeline'):
		gst.Pipeline.__init__(self, name)

		self.vid = vid
		self.needy = False

		self.appsrc = gst.element_factory_make('appsrc', 'file')

		self.flvdemux = gst.element_factory_make('flvdemux', 'demux')

		self.adec = gst.element_factory_make('flump3dec', 'adec')

		self.vsink = gst.element_factory_make('xvimagesink', 'vsink')
		self.asink = gst.element_factory_make('autoaudiosink', 'asink')

		self.aconv = gst.element_factory_make('audioconvert', 'aconv')
		self.cspace = gst.element_factory_make('autoconvert', 'vconv')

		self.qv = gst.element_factory_make('queue', 'qv')
		self.qa = gst.element_factory_make('queue', 'qa')

		self.flvdemux.connect('pad-added', self.demux_pad)

		self.add(self.appsrc,
				self.flvdemux,
				self.adec,
				self.aconv,
				self.cspace,
				self.qv,
				self.qa,
				self.vsink,
				self.asink)

		gst.element_link_many(self.appsrc, self.flvdemux)
		gst.element_link_many(self.cspace, self.vsink)
		gst.element_link_many(self.qa, self.adec,
					self.aconv, self.asink)

		if self.vid is not None:
			self.appsrc.connect('need-data', self.need_data)
			self.appsrc.connect('enough-data', self.enough_data)

class VideoArea(gtk.DrawingArea):
	def __init__(self):
		gtk.DrawingArea.__init__(self)
		self.pipeline = None

	def setup(self, vid = None):
		self.pipeline = VidPipeline(vid)
		bus = self.pipeline.get_bus()
		bus.add_signal_watch()
		bus.enable_sync_message_emission()
		bus.connect('message', self.on_message)
		bus.connect('sync-message::element', self.on_sync_message)

	def on_sync_message(self, bus, msg):
		if msg.structure is None:
			return
		n = msg.structure.get_name()
		if n == 'prepare-xwindow-id':
			vsink = msg.src
			vsink.set_property('force-aspect-ratio', True)
			gtk.gdk.threads_enter()
			vsink.set_xwindow_id(self.window.xid)
			gtk.gdk.threads_leave()

	def on_message(self, bus, msg):
		t = msg.type
		if t == gst.MESSAGE_EOS:
			self.pipeline.set_state(gst.STATE_NULL)
		elif t == gst.MESSAGE_ERROR:
			(err, debug) = msg.parse_error()
			self.pipeline.set_state(gst.STATE_NULL)
			print err, debug
		elif t == gst.MESSAGE_STATE_CHANGED:
			(_,old,new) = msg.parse_state_changed()
			if old == new:
				return
			if new != gst.STATE_PLAYING:
				return
			vpad = self.pipeline.vsink.get_pad('sink')
			caps = vpad.get_negotiated_caps()
			if caps is None:
				return
			s = caps.get_structure(0)
			x = y = -1
			if s.has_key('width'):
				x = int(s['width'])
			if s.has_key('height'):
				y = int(s['height'])
			self.set_size_request(x, y)

	def play(self):
		if self.pipeline is not None:
			self.pipeline.set_state(gst.STATE_PLAYING)
	def stop(self):
		if self.pipeline is not None:
			self.pipeline.set_state(gst.STATE_NULL)

class WebThread(threading.Thread):
	def convert(self, d, url):
		v = mayhem.vars()
		v.sid = int(d['p_sid'])
		v.pid = int(d['p_pid'])
		v.hd = int(d.get('p_hd', 0))
		v.ft = int(d['p_ft'])
		v.srv = int(d['p_srv'])
		v.tcUrl = d['turbo'].rsplit(';', 1)[0]
		v.signupargs = d.get('p_signupargs')
		v.sessiontype = d.get('sessionType')
		v.nickname = d.get('p_nickname')
		v.sakey = d.get('p_sakey')
		v.g = d.get('p_g')
		v.ldmov = d.get('p_ldmov')
		v.sk = d.get('p_sk')
		v.pageurl = url
		return v

	def got_vars(self, v):
		gtk.gdk.threads_enter()
		self.win.got_vars(v)
		gtk.gdk.threads_leave()

	def __init__(self, url, win):
		threading.Thread.__init__(self)
		self.daemon = True
		self.url = url
		self.win = win

	def run(self):
		u = urlparse(self.url)
		if u.scheme != 'http':
			raise Exception, 'HTTP URLs only'
		conn = httplib.HTTPConnection(u.hostname, u.port)
		conn.request('GET', u.path)
		r = conn.getresponse()
		if r.status != 200:
			raise Exception, r.status, r.reason
		html = r.read()

		h = pymayhem.WebParser()
		h.feed(html)
		v = self.convert(h.result, self.url)
		self.got_vars(v)

class ChatBar(gtk.VBox):
	def __init__(self):
		gtk.VBox.__init__(self)
		self.nick = gtk.Label('guest')
		self.entry = gtk.Entry()

		hb = gtk.HBox()
		hb.pack_start(self.nick, False, False, 8)
		hb.pack_start(self.entry, True, True, 0)

		self.chat = gtk.TextView()
		self.chat.set_border_window_size(gtk.TEXT_WINDOW_LEFT, 8)
		self.chat.set_editable(False)

		scr = gtk.ScrolledWindow()
		scr.set_policy(gtk.POLICY_NEVER, gtk.POLICY_AUTOMATIC)
		scr.add(self.chat)

		exp = gtk.Expander('Chat Messages')
		exp.add(scr)

		self.pack_start(exp, True, False, 0)
		self.pack_start(hb, True, False, 0)

class UserList(gtk.TreeView):
	def __init__(self):
		self.store = gtk.ListStore(gobject.TYPE_STRING)
		gtk.TreeView.__init__(self, self.store)

		self.set_headers_visible(True)
		self.set_headers_clickable(False)
		self.set_enable_search(False)
		self.set_search_column(0)

		r = gtk.CellRendererText()
		col = gtk.TreeViewColumn('Users', None)
		col.pack_start(r, True)
		col.add_attribute(r, 'text', 0)
		col.set_resizable(True)
		self.append_column(col)
		self.set_size_request(120, -1)

	def extend(self, arr):
		self.store.clear()
		for usr in arr:
			itr = self.store.append((usr,))
		self.expand_all()

class Header(gtk.VBox):
	def __init__(self):
		gtk.VBox.__init__(self)

		self.performer = gtk.Label()
		attr = pango.AttrList()
		attr.insert(pango.AttrWeight(pango.WEIGHT_BOLD, 0, -1))
		attr.insert(pango.AttrScale(pango.SCALE_XX_LARGE, 0, -1))

		self.performer.set_property('attributes', attr)

		self.topic = gtk.Label()
		self.topic.set_single_line_mode(False)
		self.topic.set_line_wrap(True)
		self.topic.set_width_chars(80)

		self.pack_start(self.performer, True, True, 0)
		self.pack_start(self.topic, True, True, 0)

class Bitch(gtk.VBox):
	def __init__(self, url):
		gtk.VBox.__init__(self)

		self.url = url

		self.vid = VideoArea()
		self.hdr = Header()
		self.chatbar = ChatBar()
		self.userlist = UserList()

		hb = gtk.HBox()
		hb.pack_start(self.userlist, False, True, 0)
		hb.pack_start(self.vid, True, True, 0)

		self.pack_start(self.hdr, False, False, 0)
		self.pack_start(hb, True, True, 0)
		self.pack_start(self.chatbar, False, False, 0)

		self.hdr.performer.set_text('Loading...')
		self.hdr.topic.set_text(url)

	def got_vars(self, v):
		self.hdr.performer.set_text(v.pageurl)
		self.hdr.topic.set_text(v.tcUrl)
		self.userlist.extend(['bob', 'fred', 'jimbosucksdicks'])
		try:
			self.conn = Connection(v, self)
		except mayhem.Error:
			if v.tcUrl is not None and len(v.tcUrl):
				self.hdr.performer.set_text(v.tcUrl)
			self.hdr.topic.set_text('Connection failed')

	def start(self):
		wt = WebThread(self.url, self)
		wt.start()

class Connection(mayhem.mayhem):
	def __init__(self, v, win):
		self.go = True
		self.px = {}
		self.win = win
		self.pkts = 0
		self.vidsrc = None
		# must be last
		mayhem.mayhem.__init__(self, v)

	def n2p(self, flags):
		f = [(mayhem.NBIO_READ, glib.IO_IN),
			(mayhem.NBIO_WRITE, glib.IO_OUT)]
		ret = glib.IO_ERR | glib.IO_HUP
		for (m, p) in f:
			if flags & m:
				ret |= p
		return ret
	def p2n(self, flags):
		f = [(glib.IO_IN, mayhem.NBIO_READ),
			(glib.IO_OUT, mayhem.NBIO_WRITE),
			(glib.IO_HUP, mayhem.NBIO_ERROR),
			(glib.IO_ERR, mayhem.NBIO_ERROR)]
		ret = 0
		for (p, m) in f:
			if flags & p:
				ret |= m
		return ret

	def idle(self):
#		print 'pump'
		return self.nbio_pump()

	def nbio_active(self, fd):
		if self.px.has_key(fd):
			glib.source_remove(self.px[fd])
			del self.px[fd]

	def gcb(self, fd, flags):
		flags = self.p2n(flags)
		self.nbio_set_active(fd, flags)
		glib.idle_add(self.idle)
		return False

	def nbio_inactive(self, fd, flags):
		if self.px.has_key(fd):
			glib.source_remove(self.px[fd])
#		print 'add watch for %d'%fd
		sid = glib.io_add_watch(fd, self.n2p(flags), self.gcb)
		self.px[fd] = sid

	def NaiadAuthorize(self, code, nick, bitch, sid, room):
		self.win.hdr.performer.set_text(bitch)
		self.win.chatbar.nick.set_text(nick)
		if room.topic is not None:
			self.win.hdr.topic.set_text(room.topic)

	def NaiadFreeze(self, code, u1, u2, desc):
		self.win.hdr.topic.set_text(desc)
		self.abort()

	def NaiadPreGoldShow(self, gs):
		self.win.hdr.topic.set_text('GOLD: ' + gs.showtopic)

	def NaiadAddChat(self, nick, chat):
		s = '<%s> %s\n'%(nick, chat)
		buf = self.win.chatbar.chat.get_buffer()
		buf.insert_at_cursor(s)
		i = buf.get_iter_at_offset(buf.get_char_count())
		buf.place_cursor(i)
		self.win.chatbar.chat.scroll_to_iter(i, 0.25)

	def push_flv(self, buf):
		if self.vidsrc is None:
			return
		self.win.vid.pipeline.push_data(buf)

	def stream_play(self):
		print 'play'
		self.vidsrc = VidStream()
		self.win.vid.setup(self.vidsrc)
		self.win.vid.play()

	def stream_reset(self):
		self.win.vid.stop()
		print 'reset'

	def stream_stop(self):
		self.win.vid.stop()
		print 'stop'

	def stream_error(self, code, desc):
		s = '%s: %s'%(code, desc)
		self.win.hdr.topic.set_text(s)

	def conn_error(self, code, desc):
		s = '%s: %s'%(code, desc)
		self.win.hdr.topic.set_text(s)

class MainWin(gtk.Window):
	def destroy(self, *_):
		gtk.Window.destroy(self)
		if self.in_main:
			gtk.mainquit()
			self.in_main = False

	def main(self):
		self.in_main = True
		gtk.main()

	def __accel(self, a, cb):
		agr = gtk.AccelGroup()
		(k, m) = gtk.accelerator_parse(a)
		agr.connect_group(k, m, gtk.ACCEL_VISIBLE, cb)
		self.add_accel_group(agr)

	def __init__(self, url):
		gtk.Window.__init__(self, gtk.WINDOW_TOPLEVEL)
		self.in_main = False
		self.connect('destroy', self.destroy)
		self.set_default_size(640, 480)
		self.set_title('Webcam Mayhem')

		self.__accel('<Control>Q', self.destroy)
		self.__accel('<Control>W', self.destroy)

		self.bitch = Bitch(url)
		self.add(self.bitch)

		self.show_all()
		self.bitch.start()

if __name__ == '__main__':
	from sys import argv
	gobject.threads_init()
	gtk.gdk.threads_init()
	x = MainWin(argv[1])
	x.main()
